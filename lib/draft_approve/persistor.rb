require 'draft_approve/errors'
require 'draft_approve/models/draft'
require 'draft_approve/serializers/json'

module DraftApprove
  class Persistor
    DEFAULT_CREATE_METHOD = 'create!'.freeze
    DEFAULT_UPDATE_METHOD = 'update!'.freeze
    DEFAULT_DELETE_METHOD = 'destroy!'.freeze

    # IMPORTANT NOTE: These constants are written to the database, so cannot be
    # updated without requiring a migration of existing draft data. Such a
    # migration may be very slow, since these constants are embedded in the
    # JSON generated by this serializer!
    CREATE_METHOD = 'create_method'.freeze
    UPDATE_METHOD = 'update_method'.freeze
    DELETE_METHOD = 'delete_method'.freeze

    def self.write_draft_from_model(action_type, model, options = nil)
      DraftApprove::Transaction.ensure_in_draft_transaction do
        raise(ArgumentError, 'model argument must be present') unless model.present?

        # Now we're in a Transaction, ensure we don't get multiple drafts for the same object
        if model.persisted? && Draft.pending_approval.where(draftable: model).count > 0
          raise(DraftApprove::ExistingDraftError, "#{model} has existing draft")
        end

        case action_type
        when Draft::CREATE
          raise(DraftApprove::AlreadyPersistedModelError, "#{model} is already persisted") if model.persisted?
          draftable_type = model.class.name
          draftable_id = nil
        when Draft::UPDATE
          raise(DraftApprove::UnpersistedModelError, "#{model} isn't persisted") unless model.persisted?
          draftable_type = model.class.name
          draftable_id = model.id
        when Draft::DELETE
          raise(DraftApprove::UnpersistedModelError, "#{model} isn't persisted") unless model.persisted?
          draftable_type = model.class.name
          draftable_id = model.id
        else
          raise(ArgumentError, "Unknown draft_action_type #{action_type}")
        end

        draft_transaction = DraftApprove::Transaction.current_draft_transaction!
        draft_options = sanitize_options(options)
        changes = serializer_class.changes_for_model(model)

        # Don't write no-op updates!
        return false if changes.empty? && action_type == Draft::UPDATE

        return model.draft_pending_approval = Draft.create!(
          draft_transaction: draft_transaction,
          draftable_type: draftable_type,
          draftable_id: draftable_id,
          draft_action_type: action_type,
          draft_serializer: serializer_class.name,
          draft_changes: changes,
          draft_options: draft_options
        )
      end
    end

    def self.write_model_from_draft(draft)
      if serializer_class_name = draft.draft_serializer
        serializer = Object.const_get(serializer_class_name)
      else
        serializer = serializer_class # Use default serializer
      end
      new_values_hash = serializer.new_values_for_draft(draft)
      options = draft.draft_options || {}

      case draft.draft_action_type
      when Draft::CREATE
        raise(DraftApprove::NoDraftableError, "No draftable_type for #{draft}") if draft.draftable_type.blank?

        create_method = (options.include?(CREATE_METHOD) ? options[CREATE_METHOD] : DEFAULT_CREATE_METHOD)

        model_class = Object.const_get(draft.draftable_type)
        model = model_class.send(create_method, new_values_hash)

        # We've only just persisted the model, the draft can't have referenced it before!
        draft.update!(draftable: model)

        return model
      when Draft::UPDATE
        raise(DraftApprove::NoDraftableError, "No draftable for #{draft}") if draft.draftable.blank?

        update_method = (options.include?(UPDATE_METHOD) ? options[UPDATE_METHOD] : DEFAULT_UPDATE_METHOD)

        model = draft.draftable
        model.send(update_method, new_values_hash)
        return model
      when Draft::DELETE
        raise(DraftApprove::NoDraftableError, "No draftable for #{draft}") if draft.draftable.blank?

        delete_method = (options.include?(DELETE_METHOD) ? options[DELETE_METHOD] : DEFAULT_DELETE_METHOD)

        model = draft.draftable
        model.send(delete_method)
        return model
      else
        raise(ArgumentError, "Unknown draft_action_type #{draft.draft_action_type}")
      end
    end

    private

    def self.serializer_class
      # TODO: Factor this out into a config setting or something...
      DraftApprove::Serializers::Json
    end

    def self.sanitize_options(options)
      return nil unless options

      draft_options_keys = [CREATE_METHOD, UPDATE_METHOD, DELETE_METHOD]

      options_with_str_keys = Hash[options.map { |k, v| [k.to_s, v] }]
      unless (options_with_str_keys.keys - draft_options_keys).empty?
        raise(ArgumentError, "Unrecognised option(s) when writing draft: #{(options_with_str_keys.keys - draft_options_keys)}")
      end

      return options_with_str_keys
    end
  end
end
